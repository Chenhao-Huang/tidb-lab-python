import time
import threading
from demo_connection import get_connection


def setup_tables(cursor):
    """Create test tables for AUTO_RANDOM demonstration"""
    # Drop tables if they exist
    cursor.execute("DROP TABLE IF EXISTS auto_random_demo")
    cursor.execute("DROP TABLE IF EXISTS auto_increment_demo")

    # Create a table with AUTO_RANDOM
    cursor.execute("""
        CREATE TABLE auto_random_demo (
            id BIGINT PRIMARY KEY AUTO_RANDOM,
            name VARCHAR(255)
        )
    """)
 
    # Create a similar table with AUTO_INCREMENT for comparison
    cursor.execute("""
        CREATE TABLE auto_increment_demo (
            id BIGINT PRIMARY KEY AUTO_INCREMENT,
            name VARCHAR(255)
        )
    """)

    print("Tables created successfully.")


def show_table_definition(cursor, table_name):
    """Show the CREATE TABLE statement to verify AUTO_RANDOM settings"""
    cursor.execute(f"SHOW CREATE TABLE {table_name}")
    result = cursor.fetchone()
    print(f"\nTable definition for {table_name}:")
    print(result[1])  # The second column contains the CREATE TABLE statement


def concurrent_insert_worker(table_name, values, thread_id):
    """Worker function for concurrent inserts"""
    try:
        with get_connection(autocommit=True) as connection:
            with connection.cursor() as cursor:
                # Insert data
                insert_stmt = f"INSERT INTO {table_name} (name) VALUES (%s)"
                for i, value in enumerate(values):
                    cursor.execute(insert_stmt, (value,))
                    if i % 5 == 0:  # Print progress every 5 inserts
                        print(f"Thread {thread_id}: Inserted '{value}' into {table_name}")
        
        print(f"Thread {thread_id}: Completed all inserts for {table_name}")
    except Exception as e:
        print(f"Thread {thread_id}: Error inserting into {table_name}: {e}")


def insert_data_concurrent(count=10, num_threads=5):
    """Insert data into both tables using multiple concurrent threads"""
    # Generate values for each table
    auto_random_values = [f"Auto-random value {i}" for i in range(count)]
    auto_increment_values = [f"Auto-increment value {i}" for i in range(count)]
    
    # Divide work among threads
    items_per_thread = count // num_threads
    threads = []
    
    print(f"\nStarting {num_threads} threads to insert {count} rows into each table...")
    
    # Create and start threads for AUTO_RANDOM table
    for i in range(num_threads):
        start_idx = i * items_per_thread
        end_idx = start_idx + items_per_thread if i < num_threads - 1 else count
        thread_values = auto_random_values[start_idx:end_idx]
        
        thread = threading.Thread(
            target=concurrent_insert_worker,
            args=("auto_random_demo", thread_values, f"AR-{i+1}")
        )
        threads.append(thread)
        thread.start()
    
    # Create and start threads for AUTO_INCREMENT table
    for i in range(num_threads):
        start_idx = i * items_per_thread
        end_idx = start_idx + items_per_thread if i < num_threads - 1 else count
        thread_values = auto_increment_values[start_idx:end_idx]
        
        thread = threading.Thread(
            target=concurrent_insert_worker,
            args=("auto_increment_demo", thread_values, f"AI-{i+1}")
        )
        threads.append(thread)
        thread.start()
    
    # Wait for all threads to complete
    for thread in threads:
        thread.join()
    
    print(f"Concurrent insert completed: {count} rows inserted into each table using {num_threads} threads")


def compare_ids(cursor):
    """Compare the IDs generated by AUTO_RANDOM and AUTO_INCREMENT"""
    # Get AUTO_RANDOM IDs
    cursor.execute("SELECT id FROM auto_random_demo ORDER BY id")
    auto_random_rows = cursor.fetchall()
    
    # Get AUTO_INCREMENT IDs
    cursor.execute("SELECT id FROM auto_increment_demo ORDER BY id")
    auto_increment_rows = cursor.fetchall()
    
    print("\n=== ID Comparison: AUTO_RANDOM vs AUTO_INCREMENT ===")
    print("\nAUTO_RANDOM IDs (distributed to avoid hotspots):")
    for id_val in auto_random_rows:
        print(f"{id_val[0]}")
    
    print("\nAUTO_INCREMENT IDs (sequential, can cause hotspots):")
    for id_val in auto_increment_rows:
        print(f"{id_val[0]}")


def cleanup(cursor):
    """Drop the test tables"""
    cursor.execute("DROP TABLE IF EXISTS auto_random_demo")
    cursor.execute("DROP TABLE IF EXISTS auto_increment_demo")
    print("\nCleanup complete. Test tables dropped.")


def main():
    """Main function to run the AUTO_RANDOM demonstration"""
    with get_connection() as connection:
        print(f"Connected to TiDB: {connection.user}@{connection.server_host}:{connection.server_port}")

        with connection.cursor() as cursor:
            # Create tables
            setup_tables(cursor)
            connection.commit()

            # Show table definitions
            show_table_definition(cursor, "auto_increment_demo")
            show_table_definition(cursor, "auto_random_demo")

            # Insert data using multiple concurrent threads
            # Adjust these parameters to control the concurrency level and total insert count
            num_threads = 5  # Number of concurrent threads per table
            total_inserts = 10  # Total number of rows to insert into each table
            
            insert_data_concurrent(count=total_inserts, num_threads=num_threads)
            
            # Compare the IDs
            compare_ids(cursor)
            
            # Cleanup
            cleanup(cursor)


if __name__ == "__main__":
    main()
